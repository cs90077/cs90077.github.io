[{"categories":[],"content":"前言 請先閱讀：TableView基本使用  Components區塊模組設計的想法，來自於「TableView Content: Static Cells」的使用，優點是可以將Cell簡單直接設計在TableView上面，除了讓UI設計可以一目瞭然，還可以快速調整想要的位置順序。而缺點就是Cell無法製作成Xib模板。\n示意圖：靜態TableView 如果想要設計「設定頁面」，會設計不同的Cell樣式，使用Components的方式設計去組合畫面，達成模組開發的需求，可以提供UI大家共同使用，也為團隊往後快速開發與維護盡一份心力。\n作法 step 1 Data Model - 將你所設計好的各種TableViewCell，透過Enum列舉包裝物件，並且用陣列的方式儲存資料項目。 - 優點：隨時可新增Cell，並且調整項目順序。  1// PreferenceViewModel.swift 2 3import Foundation 4import UIKit 5 6class PreferenceViewModel { 7 static let cellComponents: [PreferenceCellType] = [.image, .title, .detail, .editText, .switchItem, .color] 8} 9 10enum PreferenceCellType { 11 case image 12 case title 13 case detail 14 case editText 15 case switchItem 16 case color 17} 18 19extension PreferenceCellType { 20 21 var cellId: String { 22 switch self { 23 case .image: 24 return CustomTableViewImageCell.identifier 25 case .title: 26 return CustomTableViewTitleCell.identifier 27 case .detail: 28 return CustomTableViewDetailCell.identifier 29 case .editText: 30 return CustomTableViewEditTextCell.identifier 31 case .switchItem: 32 return CustomTableViewSwitchCell.identifier 33 case .color: 34 return CustomTableViewColorCell.identifier 35 } 36 } 37 38 var cellHeight: CGFloat { 39 switch self { 40 case .image: 41 return CustomTableViewImageCell.height 42 case .title: 43 return CustomTableViewTitleCell.height 44 case .detail: 45 return CustomTableViewDetailCell.height 46 case .editText: 47 return CustomTableViewEditTextCell.height 48 case .switchItem: 49 return CustomTableViewSwitchCell.height 50 case .color: 51 return CustomTableViewColorCell.height 52 } 53 } 54 55} 如果下次你想要調整順序，只需要改變cellComponents資料即可。  1// PreferenceViewModel.swift 2 3// static let cellComponents: [PreferenceCellType] = [.image, .title, .detail, .editText, .switchItem, .color] 4 5static let cellComponents: [PreferenceCellType] = [.image, .title, .detail, .color, .switchItem, .editText ] step 2 Setup View dataSource來源改成cellComponents所設定的資料  1// PreferenceViewController.swift 2 3var dataSource: [PreferenceCellType] = PreferenceViewModel.cellComponents cellComponents的另一個好處就是，可以簡單快速的註冊所有TableView要使用到的Nib。  1// PreferenceViewController.swift 2 3func setupTableView() { 4 5 let tableView = UITableView(frame: CGRect( 6 x: 0, y: 20, 7 width: self.view.bounds.width, 8 height: self.view.bounds.height - 20), 9 style: .grouped) 10 self.view.addSubview(tableView) 11 12 tableView.delegate = self 13 tableView.dataSource = self 14 15 // 註冊 cell 16 for component in PreferenceViewModel.cellComponents { 17 let nib = UINib(nibName: component.cellId, bundle: nil) 18 tableView.register(nib, forCellReuseIdentifier: component.cellId) 19 } 20 21} other 如果你TableViewCell的項目不多，也可以設定成「項目Cell總高度未超過TableView高度」，則不可有滑動效果。  1// PreferenceViewController.swift 2 3func setupTableViewScrollEnabled() { 4 var cellsHeight: CGFloat = 0.0 5 for component in PreferenceViewModel.cellComponents { 6 cellsHeight += component.cellHeight 7 } 8 tableView.isScrollEnabled = (cellsHeight \u0026gt; tableView.frame.height) 9} step 3 DataSource 透過Switch的方式去設定Cell，目的是為了讓往後調整Cell項目時，不必大動干戈的做修改，只需要簡單的調整cellComponents即可～舒服！  1// PreferenceViewController.swift 2 3// 設定cell資料 4func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell { 5 6 let component = dataSource[indexPath.row] 7 switch component { 8 case .image: 9 guard let cell = tableView.dequeueReusableCell(withIdentifier: component.cellId) as? CustomTableViewImageCell else { return UITableViewCell() } 10 return cell 11 12 case .title: 13 guard let cell = tableView.dequeueReusableCell(withIdentifier: component.cellId) as? CustomTableViewTitleCell else { return UITableViewCell() } 14 return cell 15 16 case .detail: 17 guard let cell = tableView.dequeueReusableCell(withIdentifier: component.cellId) as? CustomTableViewDetailCell else { return UITableViewCell() } 18 return cell 19 20 case .editText: 21 guard let cell = tableView.dequeueReusableCell(withIdentifier: component.cellId) as? CustomTableViewEditTextCell else { return UITableViewCell() } 22 return cell 23 24 case .switchItem: 25 guard let cell = tableView.dequeueReusableCell(withIdentifier: component.cellId) as? CustomTableViewSwitchCell else { return UITableViewCell() } 26 return cell 27 28 case .color: 29 guard let cell = tableView.dequeueReusableCell(withIdentifier: component.cellId) as? CustomTableViewColorCell else { return UITableViewCell() } 30 return cell 31 } 32 33} 完成效果 ","date":"Sep 15, 2021","img":"/images/posts/swift_tableview_custom_components_1631779179.png","permalink":"/posts/ios/swift/tableview/tableview_custom_components/","series":["iOS"],"tags":["Swift","UITableView","UITableViewCell","UINib"],"title":"TableView設計模式：Components區塊模組"},{"categories":[],"content":"請先閱讀：TableView基本使用  作法 step 1 Create Hander View 製作好Header畫面，outlet連結UI  1// CustomTableViewHeader.swift 2 3class CustomTableViewHeader: UITableViewHeaderFooterView { 4 5 static var identifier = \u0026#34;CustomTableViewHeader\u0026#34; 6 7 static var height: CGFloat = 80 8 9 @IBOutlet weak var lblTitle: UILabel! 10 11} step 2 register header - TableView註冊Header，才可以使用View元件  1// ViewController.swift 2 3// 註冊 section 4tableView.register(UINib(nibName: \u0026#34;CustomTableViewHeader\u0026#34;, bundle: nil), forHeaderFooterViewReuseIdentifier: \u0026#34;CustomTableViewHeader\u0026#34;) step 3 DataSource - 一般設定Header標題是使用titleForHeaderInSection - 而客製化UIView則是選用viewForHeaderInSection  1// ViewController.swift 2 3// 設定section高度 4func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -\u0026gt; CGFloat { 5 return CustomTableViewHeader.height 6} 7 8// 設定Header 9func tableView(_ tableView: UITableView, viewForHeaderInSection section: Int) -\u0026gt; UIView? { 10 guard let headerView = tableView.dequeueReusableHeaderFooterView(withIdentifier: CustomTableViewHeader.identifier) as? CustomTableViewHeader else { return UITableViewHeaderFooterView() } 11 let title = \u0026#34;\\(section)\u0026#34; 12 headerView.lblTitle.text = title 13 return headerView 14} 完成 ","date":"Sep 15, 2021","img":"/images/posts/swift_tableview_custom_hander_1631770519.png","permalink":"/posts/ios/swift/tableview/tableview_custom_header/","series":["iOS"],"tags":["Swift","UITableView","UITableViewHeaderFooterView","UINib"],"title":"TableView進階使用：客製化Header"},{"categories":[],"content":"請先閱讀：TableView基本使用  作法 step 1 Create Cell View 製作好Header畫面，outlet連結UI  1// CustomTableViewCell.swift 2 3class CustomTableViewCell: UITableViewCell { 4 5 static var identifier = \u0026#34;CustomTableViewCell\u0026#34; 6 7 static var height: CGFloat = 60 8 9 @IBOutlet weak var lblTitle: UILabel! 10 11 @IBOutlet weak var viewColorBlock: UIView! 12 13 override func awakeFromNib() { 14 super.awakeFromNib() 15 // Initialization code 16 } 17 18 override func setSelected(_ selected: Bool, animated: Bool) { 19 super.setSelected(selected, animated: animated) 20 21 // Configure the view for the selected state 22 } 23 24} step 2 register header - TableView註冊Cell，才可以使用View元件  1// ViewController.swift 2 3// 註冊 cell 4tableView.register(UINib.init(nibName: CustomTableViewCell.identifier, bundle: nil), forCellReuseIdentifier: CustomTableViewCell.identifier) step 3 DataSource 1// ViewController.swift 2 3// MARK:Table View Delegate 4 5// 設定cell高度 6func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -\u0026gt; CGFloat { 7 return CustomTableViewCell.height 8} 9 10// 設定cell資料 11func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell { 12 13 guard let cell = tableView.dequeueReusableCell(withIdentifier: CustomTableViewCell.identifier) as? CustomTableViewCell else { return UITableViewCell() } 14 15 let data = dataSource[indexPath.section][indexPath.row] 16 17 cell.lblTitle.text = data 18 19 if indexPath.row % 2 == 0 { 20 cell.viewColorBlock.backgroundColor = .red 21 } 22 else { 23 cell.viewColorBlock.backgroundColor = .blue 24 } 25 26 return cell 27} 完成 ","date":"Sep 15, 2021","img":"/images/posts/swift_tableview_custom_cell_1631689825.png","permalink":"/posts/ios/swift/tableview/tableview_custom_cell/","series":["iOS"],"tags":["Swift","UITableView","UITableViewCell","UINib"],"title":"TableView進階使用：客製化Cell"},{"categories":[],"content":"在做有關資料結構的東西，你必須要知道一件事情，基本上一個資料列表(UITableView)，會對應一個資料結構(DataSource)。\nTableView 樣式    Plain Grouped insetGrouped           - TableView的樣式，必須在一開始就設定好，沒辦法在其他地方做改變 - 如果使用預設的Cell，一樣需要註冊UITableViewCell  屬性 1// 分隔線的樣式 2tableView.separatorStyle = .singleLine 3 4// 分隔線的間距 四個數值分別代表 上、左、下、右 的間距 5tableView.separatorInset = 6 UIEdgeInsets.init(top: 0, left: 20, bottom: 0, right: 20) 7 8// 是否可以點選 cell 9tableView.allowsSelection = true 10 11// 是否可以多選 cell 12tableView.allowsMultipleSelection = false 13 14// 滾動條 15tableView.showsVerticalScrollIndicator = false 使用 setp 1 Setup 1// ViewController.swift 2 3class ViewController: UIViewController { 4 5 var dataSource: [[String]] = [] 6 7 override func viewDidLoad() { 8 super.viewDidLoad() 9 setupTableView() 10 } 11 12 func setupTableView() { 13 dataSource = [[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;],[\u0026#34;1\u0026#34;,\u0026#34;2\u0026#34;,\u0026#34;3\u0026#34;,\u0026#34;4\u0026#34;,\u0026#34;5\u0026#34;]] 14 15 let tableView = UITableView(frame: CGRect( 16 x: 0, y: 20, 17 width: self.view.bounds.width, 18 height: self.view.bounds.height - 20), 19 style: .grouped) 20 // 加入到畫面中 21 self.view.addSubview(tableView) 22 tableView.delegate = self 23 tableView.dataSource = self 24 25 // 註冊 cell 26 tableView.register(UITableViewCell.self, forCellReuseIdentifier: \u0026#34;Cell\u0026#34;) 27 } 28 29} step 2 DataSource / Delegate 1// ViewController.swift 2 3// MARK:Table View Delegate 4 5extension ViewController: UITableViewDelegate, UITableViewDataSource { 6 7 // section 8 func numberOfSections(in tableView: UITableView) -\u0026gt; Int { 9 return self.dataSource.count 10 } 11 12 // 設定section高度 13 func tableView(_ tableView: UITableView, heightForHeaderInSection section: Int) -\u0026gt; CGFloat { 14 return 30 15 } 16 17 func tableView(_ tableView: UITableView, titleForHeaderInSection section: Int) -\u0026gt; String? { 18 return \u0026#34;\u0026#34; 19 } 20 21 // 設定cell數量 22 func tableView(_ tableView: UITableView, numberOfRowsInSection section: Int) -\u0026gt; Int { 23 return self.dataSource[section].count 24 } 25 26 // 設定cell高度 27 func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -\u0026gt; CGFloat { 28 return 60 29 } 30 31 // 設定cell資料 32 func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell { 33 34 guard let cell = tableView.dequeueReusableCell(withIdentifier: \u0026#34;Cell\u0026#34;) as? UITableViewCell else { return UITableViewCell() } 35 36 let data = dataSource[indexPath.section][indexPath.row] 37 38 if let label = cell.textLabel { 39 label.text = data 40 } 41 42 return cell 43 } 44 45 // 點選cell 46 func tableView(_ tableView: UITableView, didSelectRowAt indexPath: IndexPath) { 47 print(\u0026#34;didSelectRowAt = \\(indexPath.row)\u0026#34;) 48 } 49 50} TableViewCell 樣式 Style    item demo     Basic    Right Detail    Right Detail    Subtitle     Accessory    item demo     Disclosure Indicator    Detail Disclosire    Checkmark    Detail     屬性 1// 點選的效果 2cell.selectionStyle = .none ","date":"Sep 15, 2021","img":"/images/posts/swift_tableview_basic_1631689818.png","permalink":"/posts/ios/swift/tableview/tableview_basic/","series":["iOS"],"tags":["Swift","UITableView","UITableViewCell"],"title":"TableView基本使用：資料列表"},{"categories":[],"content":"PickerView是一個很方便的項目選擇工具，對於手機APP操作資料選擇、時間選擇等等，能增加資料輸入的效率。\n設計 Picker View setp 1 UI LTTPickerView.xib\n設計好UI並且綁定與Xib的關係，這邊就不再重新介紹操作了\n請參照：客製化AlertView 使用Xib setp 2 Custom View setp 2-1 SetupView - setupView：初始化UI - 製作typealias，讓Closure回傳相關資訊  1// LTTPickerView.swift 2 3class LTTPickerView: UIViewController { 4 5 @IBOutlet weak var lblTitle: UILabel! 6 @IBOutlet weak var btnDone: UIButton! 7 @IBOutlet weak var btnCancel: UIButton! 8 @IBOutlet weak var pickerView: UIPickerView! 9 10 // done 11 typealias CompletionHandler = ((_ row: Int) -\u0026gt; Void) 12 var completionHandler:CompletionHandler? 13 14 // cnacel 15 typealias CancelHandler = (() -\u0026gt; Void) 16 var cancelHandler:CancelHandler? 17 18 var pickerTitleText: String? 19 var pickerDoneBtnText: String? 20 var pickerCancelBtnText: String? 21 22 var dataSource: [String] = [] 23 var selectedRow: Int = 0 24 25 override func viewDidLoad() { 26 super.viewDidLoad() 27 setupView() 28 } 29 30 @IBAction func donePressed(_ sender: Any) { 31 dismiss(animated: true) { 32 if let handler = self.completionHandler { 33 handler(self.selectedRow) 34 } 35 } 36 } 37 38 @IBAction func cancelPressed(_ sender: Any) { 39 dismiss(animated: true) { 40 if let handler = self.cancelHandler { 41 handler() 42 } 43 } 44 } 45 46 private func setupView() { 47 self.lblTitle.text = \u0026#34;title\u0026#34; 48 self.btnDone.setTitle(\u0026#34;done\u0026#34;, for: .normal) 49 self.btnCancel.setTitle(\u0026#34;cancel\u0026#34;, for: .normal) 50 51 self.pickerView.dataSource = self 52 self.pickerView.delegate = self 53 54 self.pickerView.selectRow(selectedRow, inComponent: 0, animated: true) 55 setupCustomView() 56 } 57 58 private func setupCustomView() { 59 // setup 60 if let text = self.pickerTitleText { 61 self.lblTitle.text = text 62 } 63 64 if let text = self.pickerDoneBtnText { 65 self.btnDone.setTitle(text, for: .normal) 66 } 67 68 if let text = self.pickerCancelBtnText { 69 self.btnCancel.setTitle(text, for: .normal) 70 } 71 } 72 73} setp 2-2 DataSource - numberOfRowsInComponent：設定資料的數量  1// LTTPickerView.swift 2 3// MARK:UIPickerViewDataSource 4 5extension LTTPickerView: UIPickerViewDataSource { 6 7 func numberOfComponents(in pickerView: UIPickerView) -\u0026gt; Int { 8 return 1 9 } 10 11 func pickerView(_ pickerView: UIPickerView, numberOfRowsInComponent component: Int) -\u0026gt; Int { 12 return dataSource.count 13 } 14 15} setp 2-3 Delegate - titleForRow：設定資料的項目 - didSelectRow：選擇器滑動選項後的事件處理  1// LTTPickerView.swift 2 3// MARK:UIPickerViewDelegate 4 5extension LTTPickerView: UIPickerViewDelegate { 6 7 func pickerView(_ pickerView: UIPickerView, titleForRow row: Int, forComponent component: Int) -\u0026gt; String? { 8 9 var txt = \u0026#34;\u0026#34; 10 if dataSource.count \u0026gt; row { 11 txt = dataSource[row] 12 } 13 14 return txt 15 } 16 17 func pickerView(_ pickerView: UIPickerView, didSelectRow row: Int, inComponent component: Int) { 18 self.selectedRow = row 19 20 print(\u0026#34;picker selected row = \\(row)\u0026#34;) 21 22 let item = dataSource[row] 23 print(\u0026#34;picker show item = \\(item)\u0026#34;) 24 } 25 26} setp 2-4 Closure 在這邊設定好Handler，因為想要選擇完成之後，按下「確定」可以接收事件。  1// LTTPickerView.swift 2 3// MARK:Func 4 5extension LTTPickerView { 6 7 func show(doneHandler:@escaping CompletionHandler, 8 cancelHandler:@escaping CancelHandler) { 9 self.modalPresentationStyle = .overFullScreen 10 self.modalTransitionStyle = .crossDissolve 11 self.completionHandler = doneHandler 12 self.cancelHandler = cancelHandler 13 } 14 15} 使用 一般顯示 - 1.設定TextField的點擊事件，點擊觸發開啟PickerView。 - 2.初始化PickerView物件之後，設定相關參數，show的部分是做closure，選擇完成後可以做後續處理動作。  1// UIViewController.swift 2 3func setupView() { 4 tfAge.addTarget(self, action: #selector(showAgePickerView), for: .touchDown) 5} 6 7@objc func showAgePickerView() { 8 let dataSource = [\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,] 9 let picker = LTTPickerView() 10 picker.dataSource = dataSource 11 picker.selectedRow = self.selectedRow 12 picker.pickerTitleText = \u0026#34;請選擇年紀\u0026#34; 13 picker.pickerDoneBtnText = \u0026#34;完成\u0026#34; 14 picker.pickerCancelBtnText = \u0026#34;取消\u0026#34; 15 16 picker.show(self) { row in 17 print(\u0026#34;done\u0026#34;) 18 print(\u0026#34;view selected row = \\(row)\u0026#34;) 19 20 let item = dataSource[row] 21 print(\u0026#34;view show item = \\(item)\u0026#34;) 22 } cancelHandler: { 23 print(\u0026#34;cancel\u0026#34;) 24 } 25} 進階顯示 像是dataSource是屬於必須填入的資訊，可以使用多型的方式呈現，讓使用者知道要傳入dataSource才能使用PickerView。  1// LTTPickerView.swift 2 3func show(_ viewController:UIViewController, 4 dataSource: [String], 5 doneHandler:@escaping CompletionHandler, 6 cancelHandler:@escaping CancelHandler) { 7 self.dataSource = dataSource 8 self.show(viewController, doneHandler: doneHandler, cancelHandler: cancelHandler) 9} 1// ViewController.swift 2 3@objc func showAgePickerView() { 4 let dataSource = [\u0026#34;18\u0026#34;,\u0026#34;19\u0026#34;,\u0026#34;20\u0026#34;,\u0026#34;21\u0026#34;,\u0026#34;22\u0026#34;,\u0026#34;23\u0026#34;,\u0026#34;24\u0026#34;,\u0026#34;25\u0026#34;,] 5 let picker = LTTPickerView() 6 picker.selectedRow = self.selectedRow 7 picker.pickerDoneBtnText = \u0026#34;完成\u0026#34; 8 picker.pickerCancelBtnText = \u0026#34;取消\u0026#34; 9 10 picker.show(self, 11 dataSource: dataSource, 12 title: \u0026#34;項目選擇器\u0026#34;) { row in 13 print(\u0026#34;done\u0026#34;) 14 print(\u0026#34;view selected row = \\(row)\u0026#34;) 15 16 let item = dataSource[row] 17 print(\u0026#34;view show item = \\(item)\u0026#34;) 18 19 self.selectedRow = row 20 self.tfAge.text = item 21 } cancelHandler: { 22 print(\u0026#34;cancel\u0026#34;) 23 24 } 25} 效果 Source Code Go ","date":"Sep 10, 2021","img":"/images/posts/pickerview_1631241655.png","permalink":"/posts/ios/swift/pickerview/pickerview_package_practise/","series":["iOS"],"tags":["Swift","PickerView"],"title":"[Swift]封裝PickerView，練習製作UI套件"},{"categories":[],"content":"想把一些重要的參數寫在info.plist設定檔裡，透過Bundle取出想要的資料\n讀取檔案  要讀取其他類型的檔案，通常會轉換成Data再另外做處理。  方法 在這邊有做兩種方式解析Json格式 - 1.Decodable - 2.SwiftyJSON套件  1class Profile: Object, Decodable { 2 3 @objc dynamic var id: String = UUID().uuidString 4 /// 標題 5 @objc public dynamic var title: String = \u0026#34;\u0026#34; 6 /// 備註 7 @objc public dynamic var notes: String = \u0026#34;\u0026#34; 8 /// 日期時間 9 @objc public dynamic var date: String = \u0026#34;\u0026#34; 10 11 public override static func primaryKey() -\u0026gt; String? { 12 return \u0026#34;id\u0026#34; 13 } 14 15 enum ProfileCodingKeys: String, CodingKey { 16 case title = \u0026#34;title\u0026#34; 17 case notes = \u0026#34;notes\u0026#34; 18 case date = \u0026#34;date\u0026#34; 19 } 20 21 convenience init(title: String, 22 notes: String, 23 date: String) { 24 self.init() 25 self.title = title 26 self.notes = notes 27 self.date = date 28 29 } 30 31 convenience required init(from decoder: Decoder) throws { 32 let container = try decoder.container(keyedBy: ProfileCodingKeys.self) 33 let title = try container.decode(String.self, forKey: .title) 34 let notes = try container.decode(String.self, forKey: .notes) 35 let date = try container.decode(String.self, forKey: .date) 36 37 self.init(title: title, 38 notes: notes, 39 date: date) 40 } 41 42 required init() { 43 super.init() 44 } 45 46 required init(value: Any, schema: RLMSchema) { 47 super.init(value: value, schema: schema) 48 } 49 50 required init(realm: RLMRealm, schema: RLMObjectSchema) { 51 super.init(realm: realm, schema: schema) 52 } 53 54} 為了避免json格式錯誤 - 當Decodable失敗後（人為疏失） - 使用Third Party: SwiftyJSON 解析資料  1func loadProfileJSONFile(fileName: String) -\u0026gt; Profile { 2 3 if let path = Bundle.main.path(forResource: fileName, ofType: \u0026#34;json\u0026#34;) { 4 do { 5 let data = try Data(contentsOf: URL(fileURLWithPath: path), options: .mappedIfSafe) 6 7 do { 8 let decoder = JSONDecoder() 9 guard let profile = try? decoder.decode(Profile.self, from: data) else { 10 11 if let json = try? JSON(data: data) { 12 13 // parse 14 let profile = Profile() 15 profile.title = json[\u0026#34;title\u0026#34;].stringValue 16 profile.notes = json[\u0026#34;notes\u0026#34;].stringValue 17 profile.date = json[\u0026#34;date\u0026#34;].stringValue 18 return profile 19 } 20 21 return Profile() 22 } 23 24 return profile 25 } 26 27 } catch { 28 // handle error 29 } 30 } 31 return Profile() 32} ","date":"Sep 7, 2021","img":"","permalink":"/posts/ios/swift/bundle_read_json/","series":["iOS"],"tags":["Swift","Bundle"],"title":"[Swift]使用Bundle讀取Json檔案"},{"categories":[],"content":"想把一些重要的參數寫在info.plist設定檔裡，透過Bundle取出想要的資料\n讀取檔案  讀取文字檔案，並且轉化為Array資料 以.txt作為範本  方法 1if let path = Bundle.main.path(forResource: \u0026#34;countries\u0026#34;, ofType: \u0026#34;txt\u0026#34;) { 2 do { 3 let countriesString = try String(contentsOfFile: path, encoding: .utf8) 4 let dataArray = countriesString.components(separatedBy: \u0026#34;\\n\u0026#34;) 5 print(dataArray) 6 } catch { 7 // handle error 8 } 9} 效果 ","date":"Sep 7, 2021","img":"/images/posts/swift_bundle_1630994402.png","permalink":"/posts/ios/swift/bundle_read_text/","series":["iOS"],"tags":["Swift","Bundle"],"title":"[Swift]使用Bundle讀取txt檔案"},{"categories":[],"content":"想把一些重要的參數寫在info.plist設定檔裡，透過Bundle取出想要的資料\n設定檔 方法  透過Dictionary的方式，透過Key，取出對應的Value  1class ServerConfig { 2 static let SERVER_CONFIG: String = \u0026#34;Server Config\u0026#34; 3 static let HOST: String = \u0026#34;host\u0026#34; 4 static let PORT: String = \u0026#34;port\u0026#34; 5 static let REALM_VERSION: String = \u0026#34;realmVersion\u0026#34; 6 7 let host: String 8 let port: String 9 let realmVersion: String 10 11 init(){ 12 let infoPlist = Bundle.main.infoDictionary 13 let serverConfig = infoPlist![ServerConfig.SERVER_CONFIG] as? [String: String] 14 self.host = serverConfig![ServerConfig.HOST]! 15 self.port = serverConfig![ServerConfig.PORT]! 16 self.realmVersion = serverConfig![ServerConfig.REALM_VERSION]! 17 } 18} ","date":"Sep 7, 2021","img":"/images/posts/swift_bundle_info_dictionary_1.png","permalink":"/posts/ios/swift/bundle_info_dictionary/","series":["iOS"],"tags":["Swift","Bundle"],"title":"[Swift]使用Bundle取得info資料"},{"categories":[],"content":"想要顯示目前的APP版本號\n設定檔 方法 1func getAppVersion()-\u0026gt;String { 2 var appVersion = \u0026#34;\u0026#34; 3 let version = Bundle.main.infoDictionary?[\u0026#34;CFBundleShortVersionString\u0026#34;] as! String 4 let build = Bundle.main.infoDictionary?[\u0026#34;CFBundleVersion\u0026#34;] as! String 5 appVersion = \u0026#34;\\(version)(\\(build))\u0026#34; 6 log.debug(\u0026#34;app version = \\(appVersion)\u0026#34;) 7 return appVersion 8} 效果 ","date":"Sep 7, 2021","img":"/images/posts/swift_bundle_app_version_1.png","permalink":"/posts/ios/swift/bundle_app_version/","series":["iOS"],"tags":["Swift","Bundle"],"title":"[Swift]使用Bundle取得APP版本號"},{"categories":[],"content":"整理一些基本常用的處理方式\n新增 1var aryData = [] 2aryData.append(\u0026#34;1\u0026#34;) 3aryData.append(\u0026#34;2\u0026#34;) 4aryData.append(\u0026#34;3\u0026#34;) 5 6print(aryData) 7// Prints [1, 2, 3] 刪除 注意：資料刪除後，index排序會重新整理，所以用「迴圈」刪除資料要小心。  1aryData.remove(at: 0) 2print(aryData) 3// Prints [2, 3] 資料排序 注意：sorted會改變原數值，sort則不會。  升序 A-Z 1var histoayArray: [History] = [] 2 3historyArray.sorted(by: { $0.date \u0026lt; $1.date } 降序 Z-A 1histoayArray = histoayArray.sort { 2 $0.title \u0026gt; $1.title 3} ","date":"Sep 2, 2021","img":"","permalink":"/posts/ios/swift/array_basic/","series":["iOS"],"tags":["Swift","Array"],"title":"[Swift]\u0008Array資料處理"},{"categories":[],"content":"會發現這個是因為APP有需要使用到Wi-Fi功能，但當使用者把「準確位置」關閉之後，APP將無法取得Wi-Fi相關資訊，這樣就變得很麻煩，所以必須引導使用者，強制開啟位置權限的「準確位置」項目，才能讓我正常取用Wi-Fi資訊。\n將準確位置關閉的話，就會變成模糊定位。\nps.最快的解決方法就是：公司要好好地告訴使用者，正確的使用規則！     準確位置：關 檢查權限          step 1 permission 在 info.plist 添加權限項目\n Privacy - Location Always and When In Use Usage Description =\u0026gt;\u0026ldquo;開啟取用位置及準確位置等權限，即可使用Wi-Fi功能。請授權「APP」使用該權限。\u0026rdquo;  step 2 function 1func checkAppPermission() { 2 3 let locationManager = locationManager 4 locationManager.requestAlwaysAuthorization() 5 locationManager.startUpdatingLocation() 6 // locationManager.allowsBackgroundLocationUpdates = true 7 locationManager.pausesLocationUpdatesAutomatically = false 8 9 // 第一次安裝為未授權 10 if CLLocationManager.authorizationStatus() == .notDetermined { 11 // 系統內建權限詢問視窗 12 locationManager.requestWhenInUseAuthorization() 13 } 14 else if CLLocationManager.authorizationStatus() == .restricted { 15 // 系統內建權限詢問視窗 16 locationManager.requestWhenInUseAuthorization() 17 } 18 else if CLLocationManager.authorizationStatus() == .denied { 19 let alertViewController = UIAlertController ( 20 title: \u0026#34;權限請求\u0026#34;, 21 message: \u0026#34;定位權限將用XXX作功能。請授權「APP」使用該權限。\u0026#34;, 22 preferredStyle: .alert) 23 24 let uploadAction = UIAlertAction( 25 title: \u0026#34;設定\u0026#34;, 26 style: .destructive, 27 handler: {_ in 28 29 if let url = URL(string: UIApplication.openSettingsURLString) { 30 UIApplication.shared.open(url, options: [:], completionHandler: nil) 31 } 32 }) 33 34 alertViewController.addAction(uploadAction) 35 36 self.present(alertViewController, animated: true, completion: nil) 37 } 38 else { 39 if #available(iOS 14.0, *) { 40 // iOS 14 新增了「準確位置」功能 41 switch locationManager.accuracyAuthorization { 42 case .reducedAccuracy: 43 print(\u0026#34;approximate location\u0026#34;) 44 45 let alertViewController = UIAlertController( 46 title: \u0026#34;權限請求\u0026#34;, 47 message: \u0026#34;請開啟準確位置，「APP」才能使用WI-FI連線功能。\u0026#34;, 48 preferredStyle: .alert) 49 50 let uploadAction = UIAlertAction( 51 title: \u0026#34;設定\u0026#34;, 52 style: .destructive, 53 handler: {_ in 54 if let url = URL(string: UIApplication.openSettingsURLString) { 55 UIApplication.shared.open(url, options: [:], completionHandler: nil) 56 } 57 }) 58 59 alertViewController.addAction(uploadAction) 60 61 self.present(alertViewController, animated: true, completion: nil) 62 63 locationManager.startUpdatingLocation() 64 case .fullAccuracy: 65 print(\u0026#34;accurate location\u0026#34;) 66 @unknown default: 67 print(\u0026#34;unknown type\u0026#34;) 68 } 69 } 70 } 71 72} 參考   [定位服務與隱私權]   [關於 iOS 與 iPadOS 的隱私權和定位服務]   相關文章   [前往「系統設定」頁面]   [檢查「允許取用位置」權限]  ","date":"Sep 1, 2021","img":"/images/posts/swift_location_1630475350.png","permalink":"/posts/ios/swift/check_location_permissions_ios14/","series":["iOS"],"tags":["Swift","Location","iOS 14"],"title":"[Swift]iOS14 位置權限新增「準確位置」項目"},{"categories":[],"content":"   檢查權限 允許：下次詢問             不允許 再次請權限求          權限 step 1 permission 在 info.plist 添加權限項目\n Privacy - Location When In Use Usage Description =\u0026gt; \u0026ldquo;定位權限將用於Wi-Fi連線與操作功能。請授權「APP」使用該權限。\u0026rdquo;  step 2 import 1import CoreLocation step 3 manager  需將CLLocationManager參數放置全域變數，如果系統會抓不到最新資料，可能會出現重複詢問的狀況。  1var locationManager : CLLocationManager = CLLocationManager() step 4 function authorizationStatus類別\n denied：永不 notDetermined：下次詢問 authorizedWhenInUse：使用APP期間 authorizedAlways：永遠 restricted：受限制的（目前我還不清楚用途  1@IBAction func donePressed(_ sender: Any) { 2 checkLocationPermission() 3} 4 5func checkLocationPermission() { 6 7 let locationManager = locationManager 8 locationManager.requestAlwaysAuthorization() 9 locationManager.startUpdatingLocation() 10 locationManager.pausesLocationUpdatesAutomatically = false 11 12 // 第一次安裝為未授權 13 if CLLocationManager.authorizationStatus() == .notDetermined { 14 // 系統內建權限詢問視窗 15 locationManager.requestWhenInUseAuthorization() 16 } 17 else if CLLocationManager.authorizationStatus() == .restricted { 18 // 系統內建權限詢問視窗 19 locationManager.requestWhenInUseAuthorization() 20 } 21 else if CLLocationManager.authorizationStatus() == .denied { 22 let alertViewController = UIAlertController ( 23 title: \u0026#34;權限請求\u0026#34;, 24 message: \u0026#34;定位權限將用XXX作功能。請授權「APP」使用該權限。\u0026#34;, 25 preferredStyle: .alert) 26 27 let uploadAction = UIAlertAction( 28 title: \u0026#34;設定\u0026#34;, 29 style: .destructive, 30 handler: {_ in 31 32 if let url = URL(string: UIApplication.openSettingsURLString) { 33 UIApplication.shared.open(url, options: [:], completionHandler: nil) 34 } 35 }) 36 37 alertViewController.addAction(uploadAction) 38 39 self.present(alertViewController, animated: true, completion: nil) 40 } 41 42} 相關文章   [前往「系統設定」頁面]   [iOS14 位置權限新增「準確位置」項目]  ","date":"Sep 1, 2021","img":"/images/posts/swift_location_1630474095.png","permalink":"/posts/ios/swift/check_location_permissions/","series":["iOS"],"tags":["Swift","Location"],"title":"[Swift]檢查「允許取用位置」權限"},{"categories":[],"content":"   1 2          1@IBAction func donePressed(_ sender: Any) { 2 callPhone() 3} 4 5func callPhone(){ 6 let txtPhone = \u0026#34;123\u0026#34; 7 if let url = URL(string: \u0026#34;tel://\\(txtPhone)\u0026#34;), UIApplication.shared.canOpenURL(url) { 8 if #available(iOS 10, *) { 9 UIApplication.shared.open(url) 10 } else { 11 UIApplication.shared.openURL(url) 12 } 13 } 14} ","date":"Aug 31, 2021","img":"/images/posts/swift_call_phone_2.png","permalink":"/posts/ios/swift/url/call_phone/","series":["iOS"],"tags":["Swift","URL"],"title":"[Swift]使用URL撥打電話"},{"categories":[],"content":"在做權限管理的時候，常常會需要請使用者去開啟權限，可以使用此方法，引導使用者去「設定頁面」操作。\n1func gotoSetting() { 2 3 if let url = URL(string: UIApplication.openSettingsURLString) { 4 UIApplication.shared.open(url, options: [:], completionHandler: nil) 5 } 6 7} ","date":"Aug 31, 2021","img":"/images/posts/swift_setting_1630474892.png","permalink":"/posts/ios/swift/url/goto_system_setting/","series":["iOS"],"tags":["Swift","URL"],"title":"[Swift]前往「系統設定」頁面"},{"categories":[],"content":"使用URL 字串拼接格式：\n「mailto:abc@mail.com?subject=我是標題\u0026amp;body=我是內容」   收件人：用 “ , “ 分開 副本：cc 密件副本：bcc 標題：subject 內容：body  1@IBAction func donePressed(_ sender: Any) { 2 sendEmail() 3} 4 5func sendEmail() { 6 let email = \u0026#34;cs90077@gmail.com\u0026#34; 7 let subject = \u0026#34;我是標題\u0026#34; 8 let body = \u0026#34;我是內容\\r\\n第二個內容\u0026#34; 9 10 let mailtoString = \u0026#34;mailto:\\(email)?subject=\\(subject)\u0026amp;body=\\(body)\u0026#34;.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? \u0026#34;\u0026#34; 11 if let url = URL(string: mailtoString) { 12 if #available(iOS 10.0, *) { 13 UIApplication.shared.open(url) 14 } else { 15 UIApplication.shared.openURL(url) 16 } 17 } 18} 使用MFMailComposeViewController step 1 import 1import MessageUI step 2 func 1@IBAction func donePressed(_ sender: Any) { 2 showMailComposer() 3} 4 5func showMailComposer() { 6 let email = \u0026#34;cs90077@gmail.com\u0026#34; 7 let subject = \u0026#34;我是標題\u0026#34; 8 let body = \u0026#34;我是內容\\r\\n第二個內容\u0026#34; 9 10 if MFMailComposeViewController.canSendMail() { 11 let composer = MFMailComposeViewController() 12 composer.mailComposeDelegate = self 13 composer.setToRecipients([email]) 14 composer.setSubject(subject) 15 composer.setMessageBody(body, isHTML: false) 16 present(composer, animated: true) 17 } 18} 19 step 3 delegate 1extension ViewController: MFMailComposeViewControllerDelegate { 2 3 func mailComposeController(_ controller: MFMailComposeViewController, didFinishWith result: MFMailComposeResult, error: Error?) { 4 if let _ = error { 5 controller.dismiss(animated: true, completion: nil) 6 return 7 } 8 9 switch result { 10 case .cancelled: 11 break 12 case .saved: 13 break 14 case .sent: 15 break 16 case .failed: 17 break 18 } 19 controller.dismiss(animated: true, completion: nil) 20 } 21 22} 驗證Email格式 1+ (BOOL)validateEmailWithString:(NSString *)email { 2 NSString *emailRegExp = @\u0026#34;[A-Z0-9a-z._+-]+@[A-Za-z0-9.-]+\\\\.[A-Za-z]{2,4}\u0026#34;; 3 NSPredicate *emailTest = [NSPredicate predicateWithFormat:@\u0026#34;SELF MATCHES %@\u0026#34;, emailRegExp]; 4 return [emailTest evaluateWithObject:email]; 5} 小細節  URL：至APP外部開啟「郵件APP」處理 View：在APP內部直接做郵件處理     URL View          issue 目前測試發現，使用mailto的方法，目前在iOS 14.6中，「 \\r\\n 」無法做出換行效果，會顯示成，而使用MFMailComposeViewController則無此問題\n[Mailto url encoding issue iOS 14.6] ","date":"Aug 31, 2021","img":"/images/posts/swift_send_email_2.png","permalink":"/posts/ios/swift/url/send_email/","series":["iOS"],"tags":["Swift","URL","MessageUI"],"title":"[Swift]發送Email信件"},{"categories":[],"content":"使用URL 1@IBAction func donePressed(_ sender: Any) { 2 sendSMS() 3} 4 5func sendSMS() { 6 let phoneNumber = \u0026#34;0911222333\u0026#34; 7 let body = \u0026#34;我是內容\\r\\n第二個內容\u0026#34; 8 9 let smsString = \u0026#34;sms:\\(phoneNumber)\u0026amp;body=\\(body)\u0026#34;.addingPercentEncoding(withAllowedCharacters: .urlQueryAllowed) ?? \u0026#34;\u0026#34; 10 if let url = URL(string: smsString) { 11 if #available(iOS 10.0, *) { 12 UIApplication.shared.open(url) 13 } else { 14 UIApplication.shared.openURL(url) 15 } 16 } 17} 使用MFMessageComposeViewController step 1 import 1import MessageUI step 2 func 1@IBAction func donePressed(_ sender: Any) { 2 showMessageComposer() 3} 4 5func showMessageComposer() { 6 let phoneNumber = \u0026#34;0911222333\u0026#34; 7 8 if (MFMessageComposeViewController.canSendText()) { 9 let composer = MFMessageComposeViewController() 10 composer.messageComposeDelegate = self 11 composer.recipients = [phoneNumber] 12 composer.body = \u0026#34;Message Body\u0026#34; 13 self.present(composer, animated: true, completion: nil) 14 } 15} step 3 delegate 1 2extension UIViewController: MFMessageComposeViewControllerDelegate { 3 4 public func messageComposeViewController(_ controller: MFMessageComposeViewController, didFinishWith result: MessageComposeResult) { 5 6 switch result { 7 case .cancelled: 8 break 9 case .sent: 10 break 11 case .failed: 12 break 13 } 14 controller.dismiss(animated: true, completion: nil) 15 } 16 17} 小細節  URL：至APP外部開啟「簡訊APP」處理 View：在APP內部直接做簡訊處理     URL View         ","date":"Aug 31, 2021","img":"/images/posts/swift_send_sms_2.png","permalink":"/posts/ios/swift/url/send_sms/","series":["iOS"],"tags":["Swift","URL","MessageUI"],"title":"[Swift]發送SMS簡訊"},{"categories":[],"content":"使用URL 1func previewWebView2() { 2 let urlString = \u0026#34;https://www.google.com\u0026#34; 3 4 if let url = URL(string: urlString) { 5 if #available(iOS 10.0, *) { 6 UIApplication.shared.open(url) 7 } 8 else { 9 UIApplication.shared.openURL(url) 10 } 11 } 12} 使用SFSafariViewController step 1 import 1import SafariServices step 2 func 1func previewWebView() { 2 let urlString = \u0026#34;https://www.google.com\u0026#34; 3 4 if let url = URL(string: urlString) { 5 let safari = SFSafariViewController.init(url: url) 6 self.present(safari, animated: true, completion: nil) 7 } 8} 小細節  URL：至APP外部開啟「Safari APP」顯示網頁 View：在APP內部直接顯示網頁     URL View         ","date":"Aug 31, 2021","img":"","permalink":"/posts/ios/swift/url/open_safari/","series":["iOS"],"tags":["Swift","URL","SafariServices"],"title":"[Swift]開啟Safari網頁"},{"categories":[],"content":"設計一個良好互動良好的AlertView，當按下確認後要讓ViewController能夠處理完成事件。\n所以需要在AlertView按鈕事件中寫Closure，製造出一個內部呼叫的Block型態。\n作法 請先閱讀: 客製化AlertView 使用Xib step 1 Typealias 自定義類別typealias，處理Closure事件。  1typealias CompletionHandler = (() -\u0026gt; Void) 2var completionHandler:CompletionHandler? step 2 Event 按下完成按鈕後，會先關閉視窗，在觸發事件回ViewController。  1@IBAction func donePressed(_ sender: Any) { 2 // closure 3 dismiss(animated: true) { 4 if let handler = self.completionHandler { 5 handler() 6 } 7 } 8} step 3 Closure 如果Closure會離開此方法，透過其他外部方式觸發回傳，則必須在CompletionHandler前方加上贅詞 @escaping。  1extension CustomAlertView { 2 3 static func show(_ viewController:UIViewController, 4 doneHandler:@escaping CompletionHandler) { 5 let page = CustomAlertView() 6 page.modalPresentationStyle = .overFullScreen 7 page.modalTransitionStyle = .crossDissolve 8 page.completionHandler = doneHandler 9 viewController.present(page, animated: true, completion: nil) 10 } 11 12} step 4 Use 在ViewController中直接呼叫出AlertView。  1func showXibAlertView() { 2 CustomAlertView.show(self) { 3 print(\u0026#34;closure\u0026#34;) 4 } 5} 進階：回傳參數資料 如果需要回傳資料也很簡單，在typealias中添加參數資料即可  step 1 AlertView  添加UITextField作為資料來源  1class CustomAlertView: UIViewController { 2 3 @IBOutlet weak var lblTitle: UILabel! 4 5 @IBOutlet weak var textfieldMessage: UITextField! 6 7 @IBOutlet weak var btnDone: UIButton! 8 9 typealias CompletionHandler = ((_ text: String) -\u0026gt; Void) 10 var completionHandler:CompletionHandler? 11 12 override func viewDidLoad() { 13 super.viewDidLoad() 14 setupView() 15 } 16 17 @IBAction func donePressed(_ sender: Any) { 18 // closure 19 dismiss(animated: true) { 20 if let handler = self.completionHandler { 21 let msg = self.textfieldMessage.text ?? \u0026#34;\u0026#34; 22 handler(msg) 23 } 24 } 25 } 26 27 func setupView() { 28 lblTitle.text = \u0026#34;標題\u0026#34; 29 textfieldMessage.placeholder = \u0026#34;文字訊息\u0026#34; 30 btnDone.setTitle(\u0026#34;確定\u0026#34;, for: .normal) 31 } 32 33} 34 35extension CustomAlertView { 36 37 static func show(_ viewController:UIViewController, 38 doneHandler:@escaping CompletionHandler) { 39 let page = CustomAlertView() 40 page.modalPresentationStyle = .overFullScreen 41 page.modalTransitionStyle = .crossDissolve 42 page.completionHandler = doneHandler 43 viewController.present(page, animated: true, completion: nil) 44 } 45 46} step 2 Use 1func showXibAlertView() { 2 CustomAlertView.show(self) { text in 3 print(text) 4 } 5} ","date":"Aug 30, 2021","img":"/images/posts/swift_alert_1630565231.png","permalink":"/posts/ios/swift/alertview/alert_closure/","series":["iOS"],"tags":["Swift","AlertController","Closure"],"title":"[Swift]AlertView透過Closure觸發回傳事件"},{"categories":[],"content":"使用UIViewController搭配Storyboard設計AlertView的樣板\n主要做法與 [客製化AlertView 使用Xib] 大致雷同\n作法 step 1 新增檔案    sb view          step 2 設計畫面    空白畫面 設計畫面          step 3 綁定關聯  綁定 class與StoryboardID   step 4 Class 1import UIKit 2 3class CustomAlertView: UIViewController { 4 5 @IBOutlet weak var lblTitle: UILabel! 6 7 @IBOutlet weak var lblMessage: UILabel! 8 9 @IBOutlet weak var btnDone: UIButton! 10 11 override func viewDidLoad() { 12 super.viewDidLoad() 13 setupView() 14 } 15 16 @IBAction func donePressed(_ sender: Any) { 17 self.dismiss(animated: true,completion: nil) 18 } 19 20 func setupView() { 21 lblTitle.text = \u0026#34;標題\u0026#34; 22 lblMessage.text = \u0026#34;文字訊息\u0026#34; 23 btnDone.setTitle(\u0026#34;確定\u0026#34;, for: .normal) 24 } 25 26} step 5 使用 1@IBAction func donePressed(_ sender: Any) { 2 showStoryboardAlertView() 3} 4 5func showStoryboardAlertView() { 6 let sb = UIStoryboard(name: \u0026#34;CustomAlertView\u0026#34;, bundle: nil) 7 let view = sb.instantiateViewController(withIdentifier: \u0026#34;CustomAlertView\u0026#34;) as! CustomAlertView 8 view.modalPresentationStyle = .overFullScreen 9 present(view, animated: true, completion: nil) 10} 相關文章  [客製化AlertView 使用Xib]  ","date":"Aug 30, 2021","img":"/images/posts/swift_alert_1630488999.png","permalink":"/posts/ios/swift/alertview/custom_alert_storyboard/","series":["iOS"],"tags":["Swift","AlertController","Storyboard"],"title":"[Swift]客製化AlertView 使用Storyboard"},{"categories":[],"content":"使用UIViewController搭配Xib設計AlertView的樣板\n作法 step 1 新增檔案    xib view          step 2 設計畫面    空白畫面 設計畫面          step 3 綁定關聯   綁定 class   綁定 View\n  按 option 拖曳\n   1 2          step 4 Class 1import UIKit 2 3class CustomAlertView: UIViewController { 4 5 @IBOutlet weak var lblTitle: UILabel! 6 7 @IBOutlet weak var lblMessage: UILabel! 8 9 @IBOutlet weak var btnDone: UIButton! 10 11 override func viewDidLoad() { 12 super.viewDidLoad() 13 setupView() 14 } 15 16 @IBAction func donePressed(_ sender: Any) { 17 self.dismiss(animated: true,completion: nil) 18 } 19 20 func setupView() { 21 lblTitle.text = \u0026#34;標題\u0026#34; 22 lblMessage.text = \u0026#34;文字訊息\u0026#34; 23 btnDone.setTitle(\u0026#34;確定\u0026#34;, for: .normal) 24 } 25 26} step 5 使用 1@IBAction func donePressed(_ sender: Any) { 2 showXibAlertView() 3} 4 5func showXibAlertView() { 6 let view = CustomAlertView() 7 view.modalPresentationStyle = .overFullScreen 8 self.present(view, animated: true, completion: nil) 9} 其他參數 效果 可自由添加轉場效果\nUIModalTransitionStyle\n coverVertical：垂直進入 flipHorizontal：水平翻轉 crossDissolve：淡入淡出  1func showXibAlertView() { 2 let view = CustomAlertView() 3 view.modalPresentationStyle = .overFullScreen 4 view.modalTransitionStyle = .crossDissolve 5 self.present(view, animated: true, completion: nil) 6} 相關文章  [客製化AlertView 使用Storyboard]  ","date":"Aug 30, 2021","img":"/images/posts/swift_alert_1630488999.png","permalink":"/posts/ios/swift/alertview/custom_alert_xib/","series":["iOS"],"tags":["Swift","AlertController","XIB"],"title":"[Swift]客製化AlertView 使用Xib"},{"categories":[],"content":"1@IBAction func donePressed(_ sender: Any) { 2 let sheet = getContactSheet() 3 self.present(sheet, animated: true, completion: nil) 4} 5 6func getContactSheet() -\u0026gt; UIAlertController { 7 let actSheet = UIAlertController(title: \u0026#34;聯絡我們\u0026#34;, message: nil, preferredStyle: .actionSheet) 8 let cancelAction = UIAlertAction(title: \u0026#34;取消\u0026#34;, style: .cancel, handler: nil) 9 let telAction = UIAlertAction(title: \u0026#34;語音客服\u0026#34;, style: .default, handler:{ action in 10 11 }) 12 let webAction = UIAlertAction(title: \u0026#34;線上客服\u0026#34;, style: .default, handler: { action in 13 14 }) 15 actSheet.addAction(cancelAction) 16 actSheet.addAction(webAction) 17 actSheet.addAction(telAction) 18 return actSheet 19} ","date":"Aug 30, 2021","img":"/images/posts/swift_alertcontroller_2.png","permalink":"/posts/ios/swift/alertview/actionsheet_basic/","series":["iOS"],"tags":["Swift","AlertController","ActionSheet"],"title":"[Swift]如何使用ActionSheet"},{"categories":[],"content":"基本使用 Alert 1func showAlert() { 2 let alert = UIAlertController(title: \u0026#34;請問是否要刪除！\u0026#34;, message: \u0026#34;\u0026#34;, preferredStyle: .alert) 3 4 let doneAction = UIAlertAction(title: \u0026#34;確定\u0026#34;, style: .default, handler: { action in 5 print(\u0026#34;ok\u0026#34;) 6 }) 7 8 let cancelAction = UIAlertAction(title: \u0026#34;取消\u0026#34;, style: .cancel, handler: nil) 9 10 alert.addAction(doneAction) 11 alert.addAction(cancelAction) 12 13 self.present(alert, animated: true, completion: nil) 14} 進階 修改Title/Message文字顏色 按鈕的文字，可以透過style直接做調整 - .default: 藍字 - .cancel: 藍字、粗體 - .destructive: 紅字  1func showAlarmAlert() { 2 let title = \u0026#34;警告\u0026#34; 3 let message = \u0026#34;不是很重要的警告!\u0026#34; 4 5 let alertViewController = UIAlertController(title: title, message: message, preferredStyle: .alert) 6 7 let txtTitle = NSAttributedString( 8 string: title, 9 attributes: [ 10 NSAttributedString.Key.foregroundColor : UIColor.darkGray 11 ]) 12 13 let txtMessage = NSAttributedString( 14 string: message, 15 attributes: [ 16 NSAttributedString.Key.foregroundColor : UIColor.red 17 ]) 18 19 alertViewController.setValue(txtTitle, forKey: \u0026#34;attributedTitle\u0026#34;) 20 alertViewController.setValue(txtMessage, forKey: \u0026#34;attributedMessage\u0026#34;) 21 22 let okAction = UIAlertAction(title: \u0026#34;ok\u0026#34;, style: .default) { action in 23 print(\u0026#34;ok\u0026#34;) 24 } 25 let cancelAction = UIAlertAction(title: \u0026#34;cancel\u0026#34;, style: .destructive, handler: nil) 26 27 alertViewController.addAction(okAction) 28 alertViewController.addAction(cancelAction) 29 self.present(alertViewController, animated: true, completion: nil) 30} 調整文字訊息:靠左 message預設是置中對齊，修改成靠左對齊\n   置中（預設） 靠左對齊          1func showTextCenterAlert() { 2 let title = \u0026#34;確定名單\u0026#34; 3 let message = \u0026#34;1.Tony\\n2.Ting\\n3.hulk\\n4.ken\u0026#34; 4 5 let alertViewController = UIAlertController(title: title, message: \u0026#34;\u0026#34;, preferredStyle: .alert) 6 7 // message style 8 let paragraphStyle = NSMutableParagraphStyle() 9 paragraphStyle.alignment = .left 10 let messageText = NSAttributedString( 11 string: message, 12 attributes: [ 13 NSAttributedString.Key.foregroundColor : UIColor.red, 14 NSAttributedString.Key.font : UIFont.systemFont(ofSize: 14), 15 NSAttributedString.Key.paragraphStyle: paragraphStyle, 16 ] 17 ) 18 alertViewController.setValue(messageText, forKey: \u0026#34;attributedMessage\u0026#34;) 19 20 let doneAction = UIAlertAction(title: \u0026#34;確定\u0026#34;, style: .default) { action in 21 print(\u0026#34;ok\u0026#34;) 22 } 23 24 alertViewController.addAction(doneAction) 25 26 self.present(alertViewController, animated: true, completion: nil) 27} ","date":"Aug 30, 2021","img":"/images/posts/swift_alertcontroller_1.png","permalink":"/posts/ios/swift/alertview/alert_basic/","series":["iOS"],"tags":["Swift","AlertController"],"title":"[Swift]如何使用AlertController"},{"categories":[],"content":"想要在整段文字中，中間特定文字切換不同屬性\n文字屬性 1var hours =19 2var title = \u0026#34;你有 \\(hours)分 可以折抵，要使用嗎？\u0026#34; 3 4let range: Range\u0026lt;String.Index\u0026gt; = title.range(of:\u0026#34; \u0026#34;)! 5let index: Int = title.distance(from: title.startIndex, to: range.lowerBound) + 1 6let length: Int = hours.description.count + 1 // 包含 “分” 7 8let attributedString = NSMutableAttributedString(string: title, attributes: [ 9 .font: UIFont(name: \u0026#34;PingFangTC-Regular\u0026#34;, size: 14.0)!, 10 .foregroundColor: UIColor.black, 11 .kern: 0.0 12]) 13 14attributedString.addAttributes([ 15 .font: UIFont(name: \u0026#34;PingFangTC-Medium\u0026#34;, size: 14.0)!, 16 .foregroundColor: UIColor.mainBlue 17], range: NSRange(location: index, length: length)) 18 19subtitleLabel.attributedText = attributedString ","date":"Aug 17, 2021","img":"/images/posts/swift_attribute_text_2.png","permalink":"/posts/ios/swift/attribute_custom/","series":["iOS"],"tags":["Swift","Attribute"],"title":"[Swift]Attribute 文字參雜不同屬性"},{"categories":[],"content":"APP顯示下一個畫面有兩種方式，第一種是用self.present，第二種是用navigationController.push 相對的，想要關閉畫面也有兩種方式，這邊寫一個func解決兩種模式的判斷，來關閉畫面。\n作法 1@IBAction func backBtnPressed(_ sender: Any) { 2 closeCurrentView() 3} 4 5func closeCurrentView(animated: Bool, completion: (() -\u0026gt; Void)?) { 6 if let nav = self.navigationController { 7 nav.popViewController(animated: animated) 8 } 9 else { 10 self.dismiss(animated: animated, completion: completion) 11 } 12} ","date":"Aug 17, 2021","img":"","permalink":"/posts/ios/swift/button/button_back_view/","series":["iOS"],"tags":["Swift","UIButton","NavigationController"],"title":"製作Back返回按鈕"},{"categories":[],"content":"按鈕＋底線=超連結樣式\n按鈕添加底線 1@IBOutlet weak var btnLink: UIButton! { 2 didSet { 3 let title = \u0026#34;連結\u0026#34; 4 let yourAttributes: [NSAttributedString.Key: Any] = [ 5 .font: UIFont.boldSystemFont(ofSize: 14), 6 .foregroundColor: UIColor.link, 7 .underlineStyle: NSUnderlineStyle.single.rawValue] 8 let attributeString = NSMutableAttributedString(string: title, 9 attributes: yourAttributes) 10 btnLink.setAttributedTitle(attributeString, for: .normal) 11 btnLink.addTarget(self, action: #selector(linkBtnPressed), for: .touchDown) 12 } 13} 14 15@objc func linkBtnPressed() { 16 print(\u0026#34;linkBtnPressed\u0026#34;) 17} ","date":"Aug 17, 2021","img":"/images/posts/swift_button_link_1631671610.png","permalink":"/posts/ios/swift/button/button_hyperlink_style/","series":["iOS"],"tags":["Swift","Attribute","UIButton"],"title":"製作HyperLink超連結按鈕"},{"categories":[],"content":"當資料有重複，想整理出不重複的資料，以下提供兩種方式給大家參考！\n傳統方法：使用for迴圈 1let array = [100, 200, 300 , 400 , 500, 100] 2// Prints [100, 200, 300, 400, 500, 100] 3var newArray: [Int] = [] 4 5for value in array { 6 if (newArray.contains(value)) { 7 continue 8 } 9 newArray.append(value) 10} 11 12print(newArray) 13// Prints [100, 200, 300, 400, 500] 進階方法：使用Filter函式 1extension Array where Element: Hashable { 2 3 func removeDuplicateElement() -\u0026gt; [Element] { 4 var elementSet = Set() 5 6 return filter { 7 elementSet.update(with: $0) == nil 8 } 9 } 10} 11 12let array = [100, 200, 300 , 400 , 500, 100] 13// Prints [100, 200, 300, 400, 500, 100] 14let newArray = array.removeDuplicateElement() 15 16print(newArray) 17// Prints [100, 200, 300, 400, 500] ","date":"Aug 1, 2021","img":"","permalink":"/posts/ios/swift/array_data_not_repeat/","series":["iOS"],"tags":["Swift","Array"],"title":"[Swift]\u0008Array取得不重複資料"},{"categories":null,"content":"小時候不懂讀書學習竅門，每天開心體驗生活，成績常駐倒數第三名。\n上高中剛好坐在學霸身邊，於是開起外掛模式，成績突飛猛進，達成文武雙全。\n- 學科: 統一入學測驗 水產類組 全校第二名 - 術科: 高職技藝競賽 漁業職種 全國第五名  已知在大學畢業後即將步入社會，所幸在此期間裡不斷地找尋各種機會可能\n大學時，為了進一步提升自己的人際關係以及團隊合作能力，有幸與學長合作共同創辦社團，擔任社長職位，且在創社三年拿到「社團評鑑 優等」殊榮。\n大學畢業前夕，考取「動力小船營業執照」以及「風浪板教練」，目標要去愛河當個遊艇船長。\n在因緣際會下認識朋友資工系的哥哥，看他如同駭客般敲鍵盤跑出一堆程式碼，覺得當工程師也太酷了，哥哥也與我分享工程師人材年薪百萬不是夢，足以克服現今社會低薪的問題。\n於是畢業後，毅然決然至「資策會」學習程式入門。在往後的半年裡，全心投入學習，課程結束時也發表三人合作開發的ERP+APP小作品，並且Android App是由自己獨立開發。\n- 2012年 六個月學習寫程式，從新手到入門，結訓發表小專題 - 2013年 四個月獨立開發政府Android APP，獲得肝指數過高 - 2014年 轉行當健身教練，重拾健康的身軀 - 2016年 重頭學習寫程式，系統性ERP開發 - 2017年 負責保全系Android APP開發，利用空閒時間學習Swift，完成同規格iOS APP開發。 - 2019年 台南\u0026gt;\u0026gt;年薪80萬   2014年 肝指數過高，轉行當健身教練，重拾健康的身軀  感謝 身邊所有朋友\n因為有你們的互相扶持成長\n才會有現在的我\n越努力，越幸運\n相信未來會越來越棒的！\n","date":"Jul 31, 2021","img":"","permalink":"/about/","series":null,"tags":null,"title":"關於我"},{"categories":[],"content":"色碼轉換器  將 RGB 轉換成 HEX 將 HEX 轉換成 RGB  使用RGB 1UIColor(red: 120.0 / 255.0, green: 125 / 255.0, blue: 112.0 / 255.0, alpha: 1) Extension 1extension UIColor { 2 3 static func RGBA(r: Float, g: Float , b: Float , a: Float) -\u0026gt; UIColor 4 { 5 return UIColor.init(red: CGFloat(CGFloat(r)/255.0), green: CGFloat(CGFloat(g)/255.0), blue: CGFloat(CGFloat(b)/255.0), alpha: CGFloat(a)) 6 } 7 8} 9 10// use 11let greyColor = UIColor.RGBA(r: 88, g: 91, b: 96, a: 1) 使用Asset Add Color Set  設定使用Hex   設定使用RGB  Extension 1 2extension UIColor { 3 4 @nonobjc class var black70: UIColor { 5 return UIColor(red: 19.0 / 255.0, green: 20.0 / 255.0, blue: 21.0 / 255.0, alpha: 0.6) 6 } 7 8} 9 10// use 11var black70 = UIColor(named: \u0026#34;black70\u0026#34;) 12 13black70 = UIColor.black70 14 15black70 = .black70 ","date":"Jun 6, 2021","img":"","permalink":"/posts/ios/swift/color_rgb/","series":["iOS"],"tags":["Swift","UIColor"],"title":"[Swift]UIColor RGB顏色的使用"},{"categories":[],"content":"Apple官方下載連結\n下載連結 More Downloads Xcodes 推薦使用Xcodes這個軟體，會列出所有目前已開放的版本\n","date":"Feb 14, 2021","img":"","permalink":"/posts/xcode/xcode_download/","series":["macOS"],"tags":["Xcode"],"title":"下載Xcode開發工具"},{"categories":[],"content":"超實用的，一轉眼清了40幾G\n透過指令 1rm -rf ~/Library/Developer/Xcode/Archives/ 2rm -rf ~/Library/Developer/Xcode/DerivedData/ 3rm -rf ~/Library/Developer/Xcode/iOS DeviceSupport/ 4rm -rf ~/Library/Developer/Xcode/Products/ 5rm -rf ~/Library/Developer/CoreSimulator/Devices/ 6rm -rf ~/Library/Developer/XCPGDevices/ DevCleaner 推薦使用DevCleaner這個軟體，幫助你一鍵清除檔案\n","date":"Feb 14, 2021","img":"","permalink":"/posts/xcode/developer_cleaner/","series":["macOS"],"tags":["Xcode"],"title":"清除Xcode肥大檔案"},{"categories":[],"content":"在 Apple Silicon M1 安裝CocoaPods套件\n基本安裝請參考：Cocopods套件管理 M1的系統架構不同，用以前的方法安裝會失敗\n需要指定x86方式安裝\n安裝套件 step1 1sudo arch -x86_64 gem install ffi step2 1arch -x86_64 pod install ","date":"Jan 25, 2021","img":"/images/icon/icon_cocoapods.png","permalink":"/posts/xcode/cocoapods_management_for_m1/","series":["iOS"],"tags":["Swift","CocoaPods","GitHub","Xcode"],"title":"安裝CocoaPods套件管理 支援M1"},{"categories":[],"content":"AppStore  RunCat: DevCleaner: Xcode工具  Homebrew 以下brew安裝方式，請參考Homebrew MacOS套件管理工具 一般軟體 常用軟體  appcleaner: 刪除軟體  1brew install --cask appcleaner  aldente: 控制電池充電  1brew install --cask aldente  bitwarden: 密碼管理  1brew install --cask bitwarden  bettertouchtool: 觸控板設定  1brew install --cask bettertouchtool  itsycal: 行事曆小程式  1brew install --cask itsycal  google-chrome  1brew install --cask google-chrome  notion: 筆記本  1brew install --cask notion  the-unarchiver: 解壓縮工具  1brew install --cask the-unarchiver  vlc: 播放器  1brew install --cask vlc 懶人包（我全都要） 1brew install --cask appcleaner 2brew install --cask aldente 3brew install --cask bitwarden 4brew install --cask bettertouchtool 5brew install --cask google-chrome 6brew install --cask itsycal 7brew install --cask notion 8brew install --cask the-unarchiver 9brew install --cask vlc 開發者 常用軟體 開發工具  xcodes  1brew install --cask xcodes  visual-studio-code  1brew install --cask visual-studio-code 封包工具  postman  1brew install --cask postman  proxyman  1brew install --cask proxyman UI工具  drawio  1brew install --cask drawio  zeplin  1brew install --cask zeplin  colorsnapper: 螢幕取色工具  1brew install --cask colorsnapper Git工具  sourcetree  1brew install --cask sourcetree  diffmerge  1brew install --cask diffmerge 資料庫工具  sqlectron  1brew install --cask sqlectron  db-browser-for-sqlite  1brew install --cask db-browser-for-sqlite  realm-studio  1brew install --cask realm-studio 其他  iterm2: 終端機  1brew install --cask iterm2  sublime-text:  1brew install --cask sublime-text  slack  1brew install --cask slack 懶人包（我全都要） 1brew install --cask colorsnapper 2brew install --cask iterm2 3brew install --cask sublime-text 4brew install --cask sourcetree 5brew install --cask diffmerge 6brew install --cask postman 7brew install --cask zeplin 8brew install --cask visual-studio-code 9brew install --cask xcodes 10brew install --cask proxyman 11brew install --cask db-browser-for-sqlite 12brew install --cask slack 13brew install --cask sqlectron 14brew install --cask realm-studio 1brew install youtube-dl 2brew install ffmpeg ","date":"Jan 1, 2021","img":"","permalink":"/posts/macos/recommended_software/","series":["macOS"],"tags":[],"title":"MacOS 推薦實用軟體"},{"categories":[],"content":"整理一些常用到的資訊\n系統 快速更新軟體 1sudo softwareupdate -i -a 釋放記憶體 1sudo purge 自動清理記憶體  1.輸入指令：  1crontab -e   2.輸入後請按「A」，別按 Enter！\n  3.輸入文字\n  1#每30分鐘自動清空記憶體 2*/30 * * * * /usr/bin/purge  4.輸入後請按「ESC」，再按下「:」，輸入「wq」，最後按下「Enter」  預設 顯示隱藏檔案 1defaults write com.apple.finder AppleShowAllFiles true; 2killall Finder    隱藏 顯示          只顯示已打開的應用程序 1defaults write com.apple.dock static-only -boolean true; 2killall Dock 變更截圖路徑 1defaults write com.apple.screencapture location ~/Downloads/screenshot; 2defaults write com.apple.screencapture type png ","date":"Jan 1, 2021","img":"","permalink":"/posts/macos/system_setting_contents/","series":["macOS"],"tags":[],"title":"MacOS 系統設定彙整"},{"categories":[],"content":"開啟相機 =\u0026gt; 拍照 =\u0026gt; 儲存照片 =\u0026gt; 簡單搞定\n開啟相機拍照 step 1 - 設定權限 info.plist 1Privacy - Camera Usage Description step 2 - 開啟相機 1func openCamera() { 2 let pickerController = UIImagePickerController() 3 pickerController.delegate = self 4 pickerController.mediaTypes = [\u0026#34;public.image\u0026#34;] 5 pickerController.sourceType = .camera 6 self.present(pickerController, animated: true, completion: nil) 7}  如果要多錄影功能，請添加 public.movie 屬性\n 1pickerController.mediaTypes = [\u0026#34;public.image\u0026#34;, \u0026#34;public.movie\u0026#34;] 效果    允許相機權限 相機頁面 拍照預覽頁面           step 3 - 取得Image 1extension OpenCameraViewController: UIImagePickerControllerDelegate, UINavigationControllerDelegate { 2 3 func imagePickerController(_ picker: UIImagePickerController, didFinishPickingMediaWithInfo info: [UIImagePickerController.InfoKey : Any]) { 4 5 guard let originalImage = info[.originalImage] as? UIImage else { return } 6 7 picker.dismiss(animated: true) { 8 DispatchQueue.main.async() { 9 self.previewImageView.image = originalImage 10 } 11 } 12 } 13 14}    拍照前 拍照後          拍照後儲存照片 step 1 - 設定權限 info.plist 1Privacy - Photo Library Additions Usage Description step 2 - 儲存圖片 1func saveImageToPhotos() { 2 // save 3 UIImageWriteToSavedPhotosAlbum(mainImage, nil, nil, nil) 4}  也可以在儲存成功後，顯示提醒視窗\n 1func saveImageToPhotos() { 2 // save 3 UIImageWriteToSavedPhotosAlbum(mainImage, imageSaveSuccess(), nil, nil) 4} 5 6@objc func imageSaveSuccess( 7 let alert = UIAlertController(title: \u0026#34;相片儲存\u0026#34;, message: \u0026#34;成功\u0026#34;, preferredStyle: .alert) 8 alert.addAction( UIAlertAction(title: \u0026#34;確認\u0026#34;, style: .default, handler: ni) 9 self.present(alert, animated: true, completion: nil) 10}    設定權限 儲存照片          Source Github ","date":"Sep 6, 2020","img":"","permalink":"/posts/ios/swift/imagepicker_%E9%96%8B%E5%95%9Fcamera%E7%9B%B8%E6%A9%9F%E5%8A%9F%E8%83%BD/","series":["iOS"],"tags":["Swift","ImagePicker","Camera"],"title":"[Swift]使用ImagePicker開啟Camera相機功能"},{"categories":[],"content":"在做開發的時候，不可能所有功能都自己寫，多少會去參考別人使用的程式function，或者引用Library套件。\n這時候套件管理就是一個很重要的工作，對於多人團隊開發相當重要，不然套件百百種，你要整理還真的很麻煩。\n幸好Cocoa他有開發出一種套件管理的Pods，提供程式設計師，直接從Github即可引用下載至專案。重點是他在會自己引用，在Burild的時候會自己編譯，超方便的！\n套件安裝 step 1 - macOS安裝CocoaPods套件 執行終端機Terminal，安裝Pod套件程式\n1$ sudo gem install cocoapods 安裝需要一點時間，請耐心等候。\nstep 2 - Xcode安裝CocoaPods套件 進入專案資料夾\n1$ cd ‘project demo\u0026#39; 初始化\n1$ pod init  會多一個Podfile檔案\n 1$ pod install 安裝完成，自動增加以下檔案\n  1.Demo.xcworkspance\n  2.Podfile.lock\n  3.Pods Finder\n  step 3 - Xcode使用Pods 開啟 Xcode xcworkspace (往後執行專案，均使用此檔案)\n選擇 Pods \u0026gt; Podfile\nstep 4 - 修改Podfile (ps.可以上Github找尋，在此示範範例為 Alamofire 套件)\n1pod \u0026#39;Alamofire\u0026#39; step 5 - 更新pod 安裝套件，他會自動偵測更新或刪除\n1$ pod install  偵測為更新   偵測為刪除  安裝完畢後，Pods會將套件編譯好放入專案中\n就可以開始使用啦～\n套件移除 CocoaPods套件管理非常的好用，但也因為他都幫你做好的關係，黏著性很強，如果想要移除或者替換其他套件管理方式(例如：Carthage)，沒有完全移除乾淨的話，專案是無法正常執行的。\nStep 1 - Delete pods from file  刪除Pods文件檔案    刪除 .xcworkspace 檔案\n  刪除 Podfile 檔案\n  刪除 Podfile.lock 檔案\n  刪除 Pods 資料夾\n  Step 2 - Delete pods from project  開啟 Demo.xcodeproj   刪除專案參考資料（遺失的項目    刪除 Pods 資料\n  刪除 Frameworkds 資料\n   Targets \u0026gt; Build Phases    刪除 Check Pods Frameworks\n  刪除 Check Pods Manifest.lock\n  刪除 Check Pods Resources\n  移除以上檔案，就可以正常Build了！(撒花\n","date":"Sep 14, 2018","img":"/images/icon/icon_cocoapods.png","permalink":"/posts/xcode/cocoapods_management/","series":["iOS"],"tags":["Swift","CocoaPods","GitHub","Xcode"],"title":"安裝CocoaPods套件管理"},{"categories":[],"content":"iOS的APP icon在規格上要求相當高，如果沒有依照它的格式去弄，是無法完美呈現在APP上的。\n如果將icon規格一一告訴UI，再請他出圖，我相信你很快會被討厭的\u0026hellip;\n有了 MakeAppicon 這個工具之後，往後不用再麻煩UI小姐，你自己也可以把圖片切好。\n準備一張原圖  上面推薦使用 1536x1536 解析度的圖，以壓縮出小Icon     選擇圖片 開始運轉          選擇規格 iOS/Android 很貼心的是，他除了有IOS的規格之外，還可以選擇Android的，依照不同的系統，需要的圖片大小也不同\n iOS規格：1x、2x、3x   Android規格：mdpi(1x)、hdpi(1.5x)、xhdpi(2x)、xxhdpi(3x)、xxhdpi(4x)  完成  成功之後，你可以直接將圖片轉寄至你的mail上面  使用效果  以iOS APP 做為使用 Project \u0026gt; Assets.xcassets  參考  MakeAppicon  裝置大小  ","date":"Sep 14, 2018","img":"","permalink":"/posts/ios/make_app_icon/","series":["iOS"],"tags":["Assets"],"title":"製作iOS APP圖示"},{"categories":[],"content":"安裝 在intel安裝 1/bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\u0026#34; 在Apple Silicon安裝 m1與install系統架構的目錄不同 主要就是前綴詞加上 arch -x86_64  1arch -x86_64 /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; 更新 1brew update \u0026amp;\u0026amp; brew upgrade \u0026amp;\u0026amp; brew cleanup 連結 [Homebrew 官網] ","date":"Jan 1, 2018","img":"","permalink":"/posts/macos/homebrew_install/","series":["macOS"],"tags":[],"title":"Homebrew MacOS套件管理工具"}]